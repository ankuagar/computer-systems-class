Homework assignment: string implementation

Now that you’ve had some practice with void *s, pointer arithmetic, and casting, you’re in a position to write a generic data structures to imitate the functionality of the C++ standard string—without using templates. This requires some very careful programming, and mandates a full understanding of the more difficult C library functions: malloc, realloc, free, memcpy, memmove, qsort, and bsearch. You’re expected to use each and every one of these, relying on the man pages to get the documentation.

Note: you’ll be coding in straight C. There are no classes, no methods, no templates, no references, no operator new, no streams. You define new types as exposed structs (C’s best imitation of the class), but all routines that initialize, destroy, and otherwise manipulate those structs must be implemented as functions.


The C string

The C string is a more flexible extension of C's built-in char *. It has some of the same basic properties: it is managed as a contiguous region of memory, all the elements in any one string are characters like 'A' or 'z', and element indexing starts at 0, not 1. But this C string differs in that it can automatically grow when characters are appended, and it can splice characters in and out of the middle. It can sort itself, and search for a character of interest.

The specific requirements of the string are detailed in the interface file attached to the end of this email. The short summary:

typedef struct {
    int logical_length;
    int allocated_length;
    char *data;
} string;

void StringNew(string *s, int initialAllocation);
void StringDispose(string *s);
int StringLength(const string *s);
char *StringNth(string *s, int position);
void StringInsert(string *s, char c, int position);
void StringAppend(string *s, char c);
void StringReplace(string *s, char c, int position);
void StringDelete(string *s, int position);
int StringSearch(const string *s, char key, int startIndex, bool isSorted);
void StringSort(string *s);

You should make liberal use of the standard C libraries to help you write your code—think of this new abstraction as a layer on top of what the standard C facilities provide. You should use the qsort and bsearch built-ins to implement sorting and binary search. Use malloc, realloc, free, memcpy, and memmove for memory management. C++'s new and delete are off limits; in fact, they won't make it past the gcc compiler.


Motivation

One could question the need for such a data type when the C++ standard library, with classes and templates like string and vector, is clearly available. Why not just program in C++? Why are we doing this? Is this really a useful skill, or is this just an academic exercise?

The fact of the matter is that the C++ string would be used for most small- and mediumscale applications where memory is abundant. But for those applications that must be embedded in systems with limited program memory (cell phones, PDAs, and so forth), code generated by template classes takes up way too much space. When you declare a C++ vector<int>, for instance, the compiler generates an int-specific version of that template and then compiles it. The declaration of a C++ vector<char *> would generate a second copy of the class, this time designed to accommodate character pointers instead of integers. If an application requires several types of C++ vectors, the amount of code generated for the templates themselves accounts for an unacceptable large fraction of the executable.

Yes, you sacrifice type safety and ease of use when you write generics in C, but the generated code is waif thin in comparison. The C string is faster, easier to maintain (at least once it’s written), and is representative of the type of custom container that systems programmers at Apple, Google, and Microsoft would write to replace the (relatively slow and heavyweight) C++ string. The perk is that you get to dabble in the very area that makes C so powerful, and once you successfully write, debug, and exercise the C string, your understanding of pointers, memory, and dynamic allocation will be top notch.


Testing your string

I’ve provided a simple test harness to exercise your string. Feel free to modify and even extend the test code to make sure your string implementation is bug-free. You are responsible for making sure your string is bulletproof, and if some flaw in your code isn’t flagged by my test, that’s still your crisis. This is a great opportunity to get your feet wet in unit testing, because the type you’re testing is very small and easily exercised.

So to complete this assignment, you should code for each of the functions in string.c. You shouldn't need to change stringtest.c at all, unless you want to write more tests. You can compile your string implementation together with the tests by running this command:

[ryan@MacBookPro ~/string-assignment]$ gcc string.c stringtest.c

That will create an executable called a.out. The first time you run it, some of the assertions will fail:

[ryan@MacBookPro ~/string-assignment]$ ./a.out
Assertion failed: (StringLength(alphabet) == 26), function TestAppend, file stringtest.c, line 42.
Abort trap: 6

Eventually, it should print output like this:

[ryan@MacBookPro ~/string-assignment]$ ./a.out
First, here is the alphabet: ABCDEFGHIJKLMNOPQRSTUVWXYZ
After append digits: ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789

After sorting: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
Found 'J' in sorted array? Yes. How about unsorted? Yes.
Found '$' in sorted array? No. How about unsorted? No.

After lowercase every other letter: 0123456789aBcDeFgHiJkLmNoPqRsTuVwXyZ

After insert dashes: 012-345-678-9aB-cDe-FgH-iJk-LmN-oPq-RsT-uVw-XyZ
After deleting dashes: 0123456789aBcDeFgHiJkLmNoPqRsTuVwXyZ
After adding and deleting at the very end: 0123456789aBcDeFgHiJkLmNoPqRsTuVwXyZ

After changing all s to *: 0123456789aBcDeFgHiJkLmNoPqR*TuVwXyZ

Erasing everything in the string by repeatedly deleting the 10th-to-last remaining character.
Almost done... deleting the last 10 elements... and we're all done!
